#include "includes.h"

typedef DWORD(__stdcall* LoadLibFn)(LPCSTR name);

int main(int argc, char* argv[])
{
	if (argc < 2)
{
	printf("usage: program.exe process.exe");
	return EXIT_FAILURE;
}

std::string process_name = argv[1];

HMODULE nt_dll = GetModuleHandleA("ntdll.dll");
if (!nt_dll) {
	printf("[-] could not get ntdll handle\n");
	return EXIT_FAILURE;
}

HMODULE kernel32 = GetModuleHandleA("kernel32.dll");
if (!kernel32) {
	printf("[-] could not get kernel32 handle\n");
	return EXIT_FAILURE;
}

LoadLibFn loadlib_func = reinterpret_cast<LoadLibFn>(GetProcAddress(kernel32, "LoadLibraryA"));
if (loadlib_func == NULL) {
	printf("[-] could not get loadlibrary function address\n");
	return EXIT_FAILURE;
}

if (!memory::get_process_id(process_name.c_str())) {
	printf("[-] could not find process id\n");
	return EXIT_FAILURE;
}

HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, false, globals::process_pid);
if (handle == NULL) {
	printf("[-] could not open process handle\n");
	return EXIT_FAILURE;
}

printf("[+] handle created to process\n");

std::ifstream dll_file("target.dll", std::ios::binary | std::ios::ate);
if (dll_file.fail())
{
	printf("[-] invalid dll file\n");
	dll_file.close();

	std::cin.get();
	return EXIT_FAILURE;
}

size_t dll_size = dll_file.tellg();
if (dll_size < 0x1000)
{
	printf("[-] invalid dll size\n");
	dll_file.close();

	std::cin.get();
	return EXIT_FAILURE;
}

// allocate memory for the dll
byte* data = new byte[static_cast<unsigned __int64>(dll_size)];

dll_file.seekg(0, std::ios::beg); // move everything to the beginning
dll_file.read(reinterpret_cast<char*>(data), dll_size); // read the file
dll_file.close(); // close it since we don't need it anymore

void* mem = VirtualAllocEx(handle, nullptr, dll_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (!mem) {
	printf("[-] failed to allocate memory\n");
	return EXIT_FAILURE;
}

printf("[+] allocated memory at %p\n", mem);

if (!WriteProcessMemory(handle, mem, data, dll_size, nullptr))
{
	printf("[-] could not write dll into target\n");
	return EXIT_FAILURE;
}

printf("[+] dll written into memory\n");

LPTHREAD_START_ROUTINE load_lib = (LPTHREAD_START_ROUTINE)GetProcAddress(kernel32, "LoadLibraryW");

//loadlib_func("target.dll"); // LoadLibrary calls DllMain, so we don't need to use shellcode

// create thread inside the process handle
HANDLE thread = CreateRemoteThread(handle, NULL, 0, load_lib, mem, 0, 0);
if (!thread) {
	printf("[-] could not create remote thread\n");
	VirtualFreeEx(handle, mem, 0, MEM_RELEASE);
	CloseHandle(handle);
	return EXIT_FAILURE;
}

WaitForSingleObject(thread, INFINITE);

printf("[+] load library called\n");

printf("[+] closing handles to processes and freeing memory\n");

VirtualFreeEx(handle, mem, 0, MEM_RELEASE); // free memory

// close all handles
CloseHandle(handle);
CloseHandle(thread);

return EXIT_SUCCESS;
}
